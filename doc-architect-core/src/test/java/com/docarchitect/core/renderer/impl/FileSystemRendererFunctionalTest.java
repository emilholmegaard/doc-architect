package com.docarchitect.core.renderer.impl;

import com.docarchitect.core.renderer.GeneratedFile;
import com.docarchitect.core.renderer.GeneratedOutput;
import com.docarchitect.core.renderer.RenderContext;
import com.docarchitect.core.renderer.RendererTestBase;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.*;

/**
 * Functional tests for {@link FileSystemRenderer}.
 *
 * <p>Tests real-world rendering scenarios with actual file I/O operations,
 * including complex directory structures, multiple file types, and edge cases.
 */
class FileSystemRendererFunctionalTest extends RendererTestBase {

    private final FileSystemRenderer renderer = new FileSystemRenderer();

    @Test
    void render_withRealWorldArchitectureDocumentation_createsCompleteStructure() throws IOException {
        // Given: A realistic architecture documentation output
        GeneratedOutput output = createGeneratedOutput(List.of(
            createGeneratedFile("README.md",
                "# Architecture Documentation\n\nGenerated by DocArchitect",
                "text/markdown"),
            createGeneratedFile("diagrams/component-diagram.mmd",
                "graph TD\n  A[User Service] --> B[Database]",
                "text/plain"),
            createGeneratedFile("diagrams/dependency-graph.md",
                "# Dependency Graph\n\n## Dependencies\n- Spring Boot 3.2.0",
                "text/markdown"),
            createGeneratedFile("reports/dependencies.md",
                "# Dependencies Report\n\nTotal: 25 dependencies",
                "text/markdown"),
            createGeneratedFile("reports/apis.md",
                "# API Endpoints\n\n- GET /users\n- POST /users",
                "text/markdown"),
            createGeneratedFile("sokrates/architecture.json",
                "{\"components\": [], \"dependencies\": []}",
                "application/json")
        ));

        // When: Rendering to filesystem
        renderer.render(output, context);

        // Then: All files should be created with correct structure
        assertThat(fileExists("README.md")).isTrue();
        assertThat(fileExists("diagrams/component-diagram.mmd")).isTrue();
        assertThat(fileExists("diagrams/dependency-graph.md")).isTrue();
        assertThat(fileExists("reports/dependencies.md")).isTrue();
        assertThat(fileExists("reports/apis.md")).isTrue();
        assertThat(fileExists("sokrates/architecture.json")).isTrue();

        // Verify content is preserved
        assertThat(readFile("README.md")).contains("Generated by DocArchitect");
        assertThat(readFile("diagrams/component-diagram.mmd")).contains("graph TD");
        assertThat(readFile("sokrates/architecture.json")).contains("\"components\"");
    }

    @Test
    void render_withMultipleDiagramTypes_createsAllFiles() throws IOException {
        // Given: Multiple diagram formats (Mermaid, PlantUML, Markdown)
        GeneratedOutput output = createGeneratedOutput(List.of(
            createGeneratedFile("diagrams/mermaid/component-diagram.mmd",
                "graph TD\n  A --> B",
                "text/plain"),
            createGeneratedFile("diagrams/plantuml/sequence.puml",
                "@startuml\nAlice -> Bob: Hello\n@enduml",
                "text/plain"),
            createGeneratedFile("diagrams/markdown/overview.md",
                "# Architecture Overview\n\n![Diagram](component-diagram.mmd)",
                "text/markdown")
        ));

        // When: Rendering all diagrams
        renderer.render(output, context);

        // Then: All diagram files created in correct directories
        assertThat(fileExists("diagrams/mermaid/component-diagram.mmd")).isTrue();
        assertThat(fileExists("diagrams/plantuml/sequence.puml")).isTrue();
        assertThat(fileExists("diagrams/markdown/overview.md")).isTrue();

        assertThat(readFile("diagrams/mermaid/component-diagram.mmd")).contains("graph TD");
        assertThat(readFile("diagrams/plantuml/sequence.puml")).contains("@startuml");
    }

    @Test
    void render_withDeepNestedStructure_createsAllDirectories() throws IOException {
        // Given: Very deep directory structure (5 levels)
        GeneratedOutput output = createGeneratedOutput(
            "docs/architecture/diagrams/services/user-service/api.md",
            "# User Service API",
            "text/markdown"
        );

        // When: Rendering deeply nested file
        renderer.render(output, context);

        // Then: All parent directories created
        Path filePath = tempDir.resolve("docs/architecture/diagrams/services/user-service/api.md");
        assertThat(filePath).exists();
        assertThat(filePath.getParent()).exists();
        assertThat(readFile("docs/architecture/diagrams/services/user-service/api.md"))
            .isEqualTo("# User Service API");
    }

    @Test
    void render_withExistingFiles_overwritesCorrectly() throws IOException {
        // Given: Existing file with old content
        Path existingFile = tempDir.resolve("report.md");
        Files.writeString(existingFile, "Old content from previous run");

        GeneratedOutput output = createGeneratedOutput(
            "report.md",
            "New content from current run",
            "text/markdown"
        );

        // When: Rendering to same location
        renderer.render(output, context);

        // Then: File should be overwritten with new content
        assertThat(readFile("report.md"))
            .isEqualTo("New content from current run")
            .doesNotContain("Old content");
    }

    @Test
    void render_withMixedContentTypes_preservesAllContent() throws IOException {
        // Given: Various content types (JSON, XML, Markdown, YAML)
        GeneratedOutput output = createGeneratedOutput(List.of(
            createGeneratedFile("config.json", "{\"setting\": \"value\"}", "application/json"),
            createGeneratedFile("config.xml", "<config><setting>value</setting></config>", "application/xml"),
            createGeneratedFile("README.md", "# Documentation", "text/markdown"),
            createGeneratedFile("config.yaml", "setting: value", "application/yaml"),
            createGeneratedFile("data.txt", "Plain text data", "text/plain")
        ));

        // When: Rendering all content types
        renderer.render(output, context);

        // Then: All files created with correct content
        assertThat(readFile("config.json")).isEqualTo("{\"setting\": \"value\"}");
        assertThat(readFile("config.xml")).contains("<config>");
        assertThat(readFile("README.md")).isEqualTo("# Documentation");
        assertThat(readFile("config.yaml")).isEqualTo("setting: value");
        assertThat(readFile("data.txt")).isEqualTo("Plain text data");
    }

    @Test
    void render_withUnicodeContent_preservesEncoding() throws IOException {
        // Given: Content with Unicode characters (emoji, special chars, non-Latin scripts)
        String unicodeContent = """
            # Architecture ğŸ—ï¸

            ## Components
            - ç”¨æˆ·æœåŠ¡ (User Service) âœ…
            - ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ (Database) ğŸ“Š
            - API Gateway ğŸšª

            ## Special Characters
            - Arrows: â†’ â† â†‘ â†“
            - Math: âˆ‘ âˆ« âˆ‚ âˆš
            - Currency: â‚¬ Â£ Â¥ â‚¹
            """;

        GeneratedOutput output = createGeneratedOutput(
            "unicode-test.md",
            unicodeContent,
            "text/markdown"
        );

        // When: Rendering Unicode content
        renderer.render(output, context);

        // Then: Unicode characters preserved
        String writtenContent = readFile("unicode-test.md");
        assertThat(writtenContent).contains("ğŸ—ï¸", "ç”¨æˆ·æœåŠ¡", "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹", "â†’", "âˆ‘", "â‚¬");
        assertThat(writtenContent).isEqualTo(unicodeContent);
    }

    @Test
    void render_withLargeNumberOfFiles_handlesEfficiently() throws IOException {
        // Given: 100 files to simulate realistic documentation generation
        List<GeneratedFile> files = new java.util.ArrayList<>();
        for (int i = 0; i < 100; i++) {
            files.add(createGeneratedFile(
                String.format("reports/service-%03d.md", i),
                String.format("# Service %d Report\n\nGenerated content", i),
                "text/markdown"
            ));
        }
        GeneratedOutput output = createGeneratedOutput(files);

        // When: Rendering many files
        long startTime = System.currentTimeMillis();
        renderer.render(output, context);
        long duration = System.currentTimeMillis() - startTime;

        // Then: All files created (performance check: < 5 seconds)
        assertThat(duration).isLessThan(5000);
        for (int i = 0; i < 100; i++) {
            assertThat(fileExists(String.format("reports/service-%03d.md", i))).isTrue();
        }

        // Verify a sample file
        assertThat(readFile("reports/service-042.md")).contains("Service 42 Report");
    }

    @Test
    void render_withEmptyContent_createsEmptyFiles() throws IOException {
        // Given: Files with empty content
        GeneratedOutput output = createGeneratedOutput(List.of(
            createGeneratedFile("empty.md", "", "text/markdown"),
            createGeneratedFile("placeholder.txt", "", "text/plain")
        ));

        // When: Rendering empty files
        renderer.render(output, context);

        // Then: Empty files created
        assertThat(fileExists("empty.md")).isTrue();
        assertThat(fileExists("placeholder.txt")).isTrue();
        assertThat(readFile("empty.md")).isEmpty();
        assertThat(readFile("placeholder.txt")).isEmpty();
    }

    @Test
    void render_withSpecialCharactersInFilenames_handlesCorrectly() throws IOException {
        // Given: Files with spaces and special characters
        GeneratedOutput output = createGeneratedOutput(List.of(
            createGeneratedFile("My Project Report.md", "# Report", "text/markdown"),
            createGeneratedFile("data (copy).txt", "Data", "text/plain"),
            createGeneratedFile("file-with-dashes.md", "Content", "text/markdown")
        ));

        // When: Rendering files with special characters
        renderer.render(output, context);

        // Then: Files created correctly
        assertThat(fileExists("My Project Report.md")).isTrue();
        assertThat(fileExists("data (copy).txt")).isTrue();
        assertThat(fileExists("file-with-dashes.md")).isTrue();
    }

    @Test
    void render_withSokratesJsonOutput_createsValidJsonFile() throws IOException {
        // Given: Realistic Sokrates JSON output
        String sokratesJson = """
            {
              "analysisDate": "2025-12-18",
              "codebase": {
                "name": "doc-architect",
                "linesOfCode": 15000
              },
              "components": [
                {"name": "Core", "linesOfCode": 8000},
                {"name": "CLI", "linesOfCode": 2000}
              ],
              "dependencies": [
                {"from": "CLI", "to": "Core", "type": "module"}
              ]
            }
            """;

        GeneratedOutput output = createGeneratedOutput(
            "sokrates/architecture.json",
            sokratesJson,
            "application/json"
        );

        // When: Rendering Sokrates output
        renderer.render(output, context);

        // Then: Valid JSON file created
        String writtenJson = readFile("sokrates/architecture.json");
        assertThat(writtenJson).contains("\"analysisDate\"", "\"components\"", "\"dependencies\"");
        assertThat(writtenJson).isEqualTo(sokratesJson);
    }
}
