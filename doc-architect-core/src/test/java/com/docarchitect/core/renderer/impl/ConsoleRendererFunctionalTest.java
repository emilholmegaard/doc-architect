package com.docarchitect.core.renderer.impl;

import com.docarchitect.core.renderer.GeneratedFile;
import com.docarchitect.core.renderer.GeneratedOutput;
import com.docarchitect.core.renderer.RenderContext;
import com.docarchitect.core.renderer.RendererTestBase;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.*;

/**
 * Functional tests for {@link ConsoleRenderer}.
 *
 * <p>Tests real-world console rendering scenarios including colored output,
 * multiple file formats, large outputs, and configuration options.
 */
class ConsoleRendererFunctionalTest extends RendererTestBase {

    private final ConsoleRenderer renderer = new ConsoleRenderer();
    private final PrintStream originalOut = System.out;
    private ByteArrayOutputStream outputStream;

    @BeforeEach
    void setUpConsole() {
        outputStream = new ByteArrayOutputStream();
        System.setOut(new PrintStream(outputStream));
    }

    @AfterEach
    void tearDownConsole() {
        System.setOut(originalOut);
    }

    @Test
    void render_withRealWorldArchitectureDocumentation_printsFormattedOutput() {
        // Given: Realistic architecture documentation
        GeneratedOutput output = createGeneratedOutput(List.of(
            createGeneratedFile("README.md",
                "# Architecture Documentation\n\nGenerated by DocArchitect\n\n## Components\n- User Service\n- Database",
                "text/markdown"),
            createGeneratedFile("diagrams/component-diagram.mmd",
                "graph TD\n  A[User Service] --> B[Database]\n  A --> C[Cache]",
                "text/plain"),
            createGeneratedFile("reports/dependencies.md",
                "# Dependencies Report\n\nTotal: 25 dependencies\n\n- Spring Boot 3.2.0\n- Jackson 2.18.0",
                "text/markdown")
        ));

        // When: Rendering to console
        renderer.render(output, context);

        // Then: Should show summary, headers, and content
        String consoleOutput = outputStream.toString();
        assertThat(consoleOutput).contains("Generated 3 file(s)");
        assertThat(consoleOutput).contains("File 1/3: README.md");
        assertThat(consoleOutput).contains("File 2/3: diagrams/component-diagram.mmd");
        assertThat(consoleOutput).contains("File 3/3: reports/dependencies.md");
        assertThat(consoleOutput).contains("Type: text/markdown");
        assertThat(consoleOutput).contains("Architecture Documentation");
        assertThat(consoleOutput).contains("graph TD");
        assertThat(consoleOutput).contains("Dependencies Report");
    }

    @Test
    void render_withColoredOutput_includesAnsiEscapeCodes() {
        // Given: Content with colors enabled
        RenderContext colorContext = createContext(tempDir.toString(), Map.of("console.colors", "true"));
        GeneratedOutput output = createGeneratedOutput(
            "report.md",
            "# Status Report\n\nAll systems operational",
            "text/markdown"
        );

        // When: Rendering with colors
        renderer.render(output, colorContext);

        // Then: Should contain ANSI color codes
        String consoleOutput = outputStream.toString();
        assertThat(consoleOutput).contains("\u001B["); // ANSI escape code prefix
        assertThat(consoleOutput).contains("\u001B[0m"); // Reset code
        assertThat(consoleOutput).contains("Status Report");
    }

    @Test
    void render_withColorDisabled_excludesAnsiEscapeCodes() {
        // Given: Content with colors explicitly disabled
        RenderContext noColorContext = createContext(tempDir.toString(), Map.of("console.colors", "false"));
        GeneratedOutput output = createGeneratedOutput(
            "report.md",
            "# Status Report\n\nAll systems operational",
            "text/markdown"
        );

        // When: Rendering without colors
        renderer.render(output, noColorContext);

        // Then: Should NOT contain ANSI color codes
        String consoleOutput = outputStream.toString();
        assertThat(consoleOutput).doesNotContain("\u001B[");
        assertThat(consoleOutput).contains("Generated 1 file(s)");
        assertThat(consoleOutput).contains("Status Report");
    }

    @Test
    void render_withCustomSeparator_usesSpecifiedSeparator() {
        // Given: Custom separator configuration
        RenderContext customContext = createContext(tempDir.toString(), Map.of(
            "console.separator", "=====",
            "console.colors", "false"
        ));
        GeneratedOutput output = createGeneratedOutput(List.of(
            createGeneratedFile("file1.md", "Content 1", "text/markdown"),
            createGeneratedFile("file2.md", "Content 2", "text/markdown")
        ));

        // When: Rendering with custom separator
        renderer.render(output, customContext);

        // Then: Should use custom separator
        String consoleOutput = outputStream.toString();
        assertThat(consoleOutput).contains("=====");
        assertThat(consoleOutput).doesNotContain("---");
    }

    @Test
    void render_withHeadersDisabled_excludesMetadata() {
        // Given: Headers disabled configuration
        RenderContext noHeadersContext = createContext(tempDir.toString(), Map.of(
            "console.showHeaders", "false",
            "console.colors", "false"
        ));
        GeneratedOutput output = createGeneratedOutput(
            "document.md",
            "# Important Document",
            "text/markdown"
        );

        // When: Rendering without headers
        renderer.render(output, noHeadersContext);

        // Then: Should exclude file headers but show summary
        String consoleOutput = outputStream.toString();
        assertThat(consoleOutput).contains("Generated 1 file(s)"); // Summary still shown
        assertThat(consoleOutput).doesNotContain("File 1/1:");
        assertThat(consoleOutput).doesNotContain("Type:");
        assertThat(consoleOutput).doesNotContain("Size:");
        assertThat(consoleOutput).contains("Important Document"); // Content still shown
    }

    @Test
    void render_withMultipleDiagramFormats_preservesFormatting() {
        // Given: Different diagram formats
        GeneratedOutput output = createGeneratedOutput(List.of(
            createGeneratedFile("mermaid.mmd",
                "graph TD\n  A --> B\n  B --> C",
                "text/plain"),
            createGeneratedFile("plantuml.puml",
                "@startuml\nAlice -> Bob: Hello\nBob -> Alice: Hi\n@enduml",
                "text/plain"),
            createGeneratedFile("markdown.md",
                "# Diagram\n\n![Component Diagram](diagram.png)\n\n## Description",
                "text/markdown")
        ));

        // When: Rendering diagrams
        renderer.render(output, context);

        // Then: Should preserve line breaks and formatting
        String consoleOutput = outputStream.toString();
        assertThat(consoleOutput).contains("graph TD\n  A --> B\n  B --> C");
        assertThat(consoleOutput).contains("@startuml\nAlice -> Bob");
        assertThat(consoleOutput).contains("![Component Diagram]");
    }

    @Test
    void render_withLargeContent_handlesEfficiently() {
        // Given: Large file content (10KB)
        String largeContent = "# Large Report\n\n" + "Lorem ipsum dolor sit amet. ".repeat(400);
        GeneratedOutput output = createGeneratedOutput(
            "large-report.md",
            largeContent,
            "text/markdown"
        );

        // When: Rendering large content
        long startTime = System.currentTimeMillis();
        renderer.render(output, context);
        long duration = System.currentTimeMillis() - startTime;

        // Then: Should handle quickly (< 1 second) and preserve content
        assertThat(duration).isLessThan(1000);
        String consoleOutput = outputStream.toString();
        assertThat(consoleOutput).contains("Large Report");
        assertThat(consoleOutput).contains("Lorem ipsum");
        assertThat(consoleOutput.length()).isGreaterThan(10000);
    }

    @Test
    void render_withUnicodeContent_preservesSpecialCharacters() {
        // Given: Content with Unicode (emoji, special chars, non-Latin scripts)
        String unicodeContent = """
            # Architecture ðŸ—ï¸

            ## Services
            - ç”¨æˆ·æœåŠ¡ (User Service) âœ…
            - ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ (Database) ðŸ“Š

            ## Arrows & Symbols
            â†’ â† â†‘ â†“ âˆ‘ âˆ« âˆ‚ âˆš â‚¬ Â£ Â¥
            """;

        GeneratedOutput output = createGeneratedOutput(
            "unicode-doc.md",
            unicodeContent,
            "text/markdown"
        );

        // When: Rendering Unicode content
        renderer.render(output, context);

        // Then: Should preserve all Unicode characters
        String consoleOutput = outputStream.toString();
        assertThat(consoleOutput).contains("ðŸ—ï¸", "ç”¨æˆ·æœåŠ¡", "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹", "âœ…", "ðŸ“Š");
        assertThat(consoleOutput).contains("â†’", "â†", "âˆ‘", "â‚¬");
    }

    @Test
    void render_withMixedContentTypes_showsCorrectMetadata() {
        // Given: Various content types
        GeneratedOutput output = createGeneratedOutput(List.of(
            createGeneratedFile("data.json", "{\"key\": \"value\"}", "application/json"),
            createGeneratedFile("config.xml", "<config/>", "application/xml"),
            createGeneratedFile("doc.md", "# Doc", "text/markdown"),
            createGeneratedFile("script.sh", "#!/bin/bash\necho 'Hello'", "application/x-sh")
        ));

        // When: Rendering mixed types
        renderer.render(output, context);

        // Then: Should show correct type for each file
        String consoleOutput = outputStream.toString();
        assertThat(consoleOutput).contains("Type: application/json");
        assertThat(consoleOutput).contains("Type: application/xml");
        assertThat(consoleOutput).contains("Type: text/markdown");
        assertThat(consoleOutput).contains("Type: application/x-sh");
    }

    @Test
    void render_withEmptyFiles_handlesGracefully() {
        // Given: Empty file content
        GeneratedOutput output = createGeneratedOutput(List.of(
            createGeneratedFile("empty.md", "", "text/markdown"),
            createGeneratedFile("placeholder.txt", "", "text/plain")
        ));

        // When: Rendering empty files
        renderer.render(output, context);

        // Then: Should show files with size 0
        String consoleOutput = outputStream.toString();
        assertThat(consoleOutput).contains("Size: 0 bytes");
        assertThat(consoleOutput).contains("File 1/2: empty.md");
        assertThat(consoleOutput).contains("File 2/2: placeholder.txt");
    }

    @Test
    void render_withNoFiles_showsEmptySummary() {
        // Given: Empty output
        GeneratedOutput output = createGeneratedOutput(List.of());

        // When: Rendering empty output
        renderer.render(output, context);

        // Then: Should show zero files
        String consoleOutput = outputStream.toString();
        assertThat(consoleOutput).contains("Generated 0 file(s)");
    }

    @Test
    void render_withAllConfigurationOptions_appliesAllSettings() {
        // Given: All settings configured
        RenderContext fullContext = createContext(tempDir.toString(), Map.of(
            "console.colors", "false",
            "console.separator", "***",
            "console.showHeaders", "true"
        ));
        GeneratedOutput output = createGeneratedOutput(List.of(
            createGeneratedFile("file1.md", "Content 1", "text/markdown"),
            createGeneratedFile("file2.txt", "Content 2", "text/plain")
        ));

        // When: Rendering with full configuration
        renderer.render(output, fullContext);

        // Then: All settings applied
        String consoleOutput = outputStream.toString();
        assertThat(consoleOutput).doesNotContain("\u001B["); // No colors
        assertThat(consoleOutput).contains("***"); // Custom separator
        assertThat(consoleOutput).contains("File 1/2:"); // Headers shown
        assertThat(consoleOutput).contains("Type: text/markdown");
    }

    @Test
    void render_withSokratesJsonOutput_displaysFormatted() {
        // Given: Sokrates JSON output
        String sokratesJson = """
            {
              "analysisDate": "2025-12-18",
              "codebase": {
                "name": "doc-architect",
                "linesOfCode": 15000
              },
              "components": [
                {"name": "Core", "linesOfCode": 8000}
              ]
            }
            """;

        GeneratedOutput output = createGeneratedOutput(
            "sokrates/architecture.json",
            sokratesJson,
            "application/json"
        );

        // When: Rendering Sokrates output
        renderer.render(output, context);

        // Then: Should display formatted JSON
        String consoleOutput = outputStream.toString();
        assertThat(consoleOutput).contains("sokrates/architecture.json");
        assertThat(consoleOutput).contains("\"analysisDate\"");
        assertThat(consoleOutput).contains("\"codebase\"");
        assertThat(consoleOutput).contains("\"components\"");
    }

    @Test
    void render_withMultipleFilesSequentially_maintainsSeparation() {
        // Given: 5 files to test separator behavior
        List<GeneratedFile> files = new java.util.ArrayList<>();
        for (int i = 1; i <= 5; i++) {
            files.add(createGeneratedFile(
                String.format("file%d.md", i),
                String.format("# File %d Content", i),
                "text/markdown"
            ));
        }
        GeneratedOutput output = createGeneratedOutput(files);

        RenderContext noColorContext = createContext(tempDir.toString(), Map.of("console.colors", "false"));

        // When: Rendering multiple files
        renderer.render(output, noColorContext);

        // Then: Files separated correctly
        String consoleOutput = outputStream.toString();
        assertThat(consoleOutput).contains("File 1/5:");
        assertThat(consoleOutput).contains("File 2/5:");
        assertThat(consoleOutput).contains("File 3/5:");
        assertThat(consoleOutput).contains("File 4/5:");
        assertThat(consoleOutput).contains("File 5/5:");

        // Count separators (should have separators between files and at start/end)
        long separatorCount = consoleOutput.lines()
            .filter(line -> line.contains("---") && line.trim().replaceAll("-", "").isEmpty())
            .count();
        assertThat(separatorCount).isGreaterThanOrEqualTo(5); // At least separators between files
    }
}
