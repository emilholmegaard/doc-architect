package com.docarchitect.cli;

import picocli.CommandLine.Command;
import picocli.CommandLine.Option;
import picocli.CommandLine.Parameters;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.concurrent.Callable;

/**
 * Command to initialize DocArchitect configuration.
 *
 * <p>Creates a {@code docarchitect.yaml} configuration file with project-detected defaults.
 * Detects Maven, Gradle, npm, or other project types and configures appropriate scanners.
 *
 * <p><b>Usage:</b>
 * <pre>{@code
 * # Initialize in current directory
 * docarchitect init
 *
 * # Initialize in specific directory
 * docarchitect init /path/to/project
 *
 * # Force overwrite existing configuration
 * docarchitect init --force
 * }</pre>
 */
@Command(
    name = "init",
    description = "Initialize configuration file with project-detected defaults",
    mixinStandardHelpOptions = true
)
public class InitCommand implements Callable<Integer> {

    private static final Logger log = LoggerFactory.getLogger(InitCommand.class);

    @Parameters(
        index = "0",
        description = "Project directory (default: current directory)",
        defaultValue = "."
    )
    private Path projectPath;

    @Option(
        names = {"-f", "--force"},
        description = "Overwrite existing configuration file"
    )
    private boolean force;

    @Option(
        names = {"-o", "--output"},
        description = "Output file name (default: docarchitect.yaml)"
    )
    private String outputFile = "docarchitect.yaml";

    @Override
    public Integer call() {
        try {
            Path configPath = projectPath.resolve(outputFile);

            // Check if config already exists
            if (Files.exists(configPath) && !force) {
                log.error("Configuration file already exists: {}", configPath);
                log.error("Use --force to overwrite");
                return 1;
            }

            log.info("Detecting project type in: {}", projectPath.toAbsolutePath());

            // Detect project type
            ProjectType projectType = detectProjectType();
            log.info("Detected project type: {}", projectType);

            // Generate configuration
            String config = generateConfiguration(projectType);

            // Write configuration file
            Files.writeString(configPath, config);

            System.out.println("âœ“ Created configuration file: " + configPath);
            System.out.println();
            System.out.println("Next steps:");
            System.out.println("  1. Review and customize " + outputFile);
            System.out.println("  2. Run 'docarchitect scan' to generate documentation");

            return 0;

        } catch (IOException e) {
            log.error("Failed to create configuration file", e);
            return 1;
        }
    }

    /**
     * Detects the project type based on build files.
     *
     * @return detected project type
     */
    private ProjectType detectProjectType() {
        if (Files.exists(projectPath.resolve("pom.xml"))) {
            return ProjectType.MAVEN;
        } else if (Files.exists(projectPath.resolve("build.gradle")) ||
                   Files.exists(projectPath.resolve("build.gradle.kts"))) {
            return ProjectType.GRADLE;
        } else if (Files.exists(projectPath.resolve("package.json"))) {
            return ProjectType.NPM;
        } else if (Files.exists(projectPath.resolve("go.mod"))) {
            return ProjectType.GO;
        } else if (Files.exists(projectPath.resolve("requirements.txt")) ||
                   Files.exists(projectPath.resolve("pyproject.toml"))) {
            return ProjectType.PYTHON;
        } else if (Files.exists(projectPath.resolve("Cargo.toml"))) {
            return ProjectType.RUST;
        }
        return ProjectType.GENERIC;
    }

    /**
     * Generates configuration content based on project type.
     *
     * @param projectType detected project type
     * @return YAML configuration content
     */
    private String generateConfiguration(ProjectType projectType) {
        String projectName = projectPath.getFileName().toString();

        return String.format("""
            # DocArchitect Configuration
            # Generated by: docarchitect init

            project:
              name: "%s"
              version: "1.0.0"

            repositories:
              - name: "main"
                path: "."

            scanners:
              enabled:
                - dependencies
                - rest-api
                - database
            %s

            generators:
              default: mermaid
              enabled:
                - mermaid
                - markdown

            output:
              directory: "./docs/architecture"
              generateIndex: true
            """,
            projectName,
            getProjectTypeSpecificConfig(projectType)
        );
    }

    /**
     * Returns project-type specific configuration.
     *
     * @param projectType project type
     * @return additional configuration lines
     */
    private String getProjectTypeSpecificConfig(ProjectType projectType) {
        return switch (projectType) {
            case MAVEN -> """
                  config:
                    maven:
                      includedScopes:
                        - compile
                        - runtime""";
            case GRADLE -> """
                  config:
                    gradle:
                      configurations:
                        - implementation
                        - api""";
            case NPM -> """
                  config:
                    npm:
                      includeDev: false""";
            default -> "";
        };
    }

    /**
     * Enum representing project types.
     */
    private enum ProjectType {
        MAVEN,
        GRADLE,
        NPM,
        GO,
        PYTHON,
        RUST,
        GENERIC
    }
}
